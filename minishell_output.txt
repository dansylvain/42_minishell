Commande: /bin/ls
Makefile
README.md
allowed_functions.md
bash_output.txt
compare_bash_and_minishell.sh
correct_output.txt
diff_output.txt
en.subject.pdf
eval_minishell.pdf
fie
file
file1
fileout
fille
fou
includes
lib
minishell
minishell_output.txt
minishell_tester
moutou
not_existing
notexisting
outfile
outfille
outfille2
output.txt
src
test_commands.txt
test_lucas
testfile
tests.sh
to_test
token
valgrind.supp
wc

Commande: echo 0
  0

Commande: 


Commande: echo 0
  0

Commande: /bin/ls -al
/bin/ls: cannot access ' ': No such file or directory

Commande: echo 0
  0

Commande: grep -i 'return' src/main.c
/usr/bin/grep:  : No such file or directory
/usr/bin/grep: return: No such file or directory
/usr/bin/grep:  : No such file or directory
src/main.c:/* ************************************************************************** */
src/main.c:/*                                                                            */
src/main.c:/*                                                        :::      ::::::::   */
src/main.c:/*   main.c                                             :+:      :+:    :+:   */
src/main.c:/*                                                    +:+ +:+         +:+     */
src/main.c:/*   By: dan <dan@student.42.fr>                    +#+  +:+       +#+        */
src/main.c:/*                                                +#+#+#+#+#+   +#+           */
src/main.c:/*   Created: 2024/01/17 14:04:56 by dan               #+#    #+#             */
src/main.c:/*   Updated: 2024/02/17 18:19:12 by dan              ###   ########.fr       */
src/main.c:/*                                                                            */
src/main.c:/* ************************************************************************** */
src/main.c:#include "../includes/minishell.h"
src/main.c:#include "parsing_utils.h"
src/main.c:char		**parse_cmd(char **command, char **env);
src/main.c:void		display_command_tab(char **command_tab);
src/main.c:int			pipex(char **argv[], char *envp[]);
src/main.c:t_ast_nde	*parse(char *str);
src/main.c:char		***create_command_tab(t_Data *data, t_ast_nde *node, char *envp[]);
src/main.c:void		display_command_tab_big(char ***command_tab);
src/main.c:void		exec_pipex(t_Data *data, char *cmd, char *envp[]);
src/main.c:void		launch_command_tab(t_Data *data, t_ast_nde *node,
src/main.c:				char *envp[], int flag);
src/main.c:int			exec_exit(t_Data *data, char **command_tab);
src/main.c: *                             COMMENTS POLICY
src/main.c: *? signal info at the end of a function's comment block 
src/main.c:*? signal info in the main comment bloc
src/main.c:*? add your name at the beggining of a comment
src/main.c:*! found free risponsible for invalid free error in file parsing_path.c
src/main.c:*TODO finish builtin export
src/main.c:*TODO fix memory leaks export
src/main.c:*TODO fix memory leaks unset
src/main.c: *                           main.c
src/main.c: *? rl_catch_signals is a global variable (from readline lib)
src/main.c:*? it is used to ignore SIGQUILL (see handle_signals.c)
src/main.c:int	main(int argc, char **argv, char *envp[])
src/main.c:	static t_Data	*data = NULL;
src/main.c:	rl_catch_signals = 0;
src/main.c:	if (data == NULL)
src/main.c:		data = (t_Data *)ft_calloc(sizeof(t_Data), 1);
src/main.c:	if (data == NULL)
src/main.c:		return (display_error("Error\n"), 255);
src/main.c:	data->envp_tab = duplicate_envp(data, envp);
src/main.c:	if (!data->envp_tab)
src/main.c:		return (display_error("Error\n"), free_data(data), 255);
src/main.c:	if (argc != 1)
src/main.c:		return (free_data(data), display_error("Usage: ./minishell\n"), 255);
src/main.c:	if (prompt_loop(data, envp) == 0)
src/main.c:		return (free_data(data), 0);
src/main.c:	return (0);
src/main.c:void	build_prompt(char prompt[])
src/main.c:	home = getenv("HOME");
src/main.c:	ft_strlcpy(prompt, "\033[1;33mminishell: \033[0m", 18);
src/main.c:	if (getcwd(cwd, sizeof(cwd)) != NULL)
src/main.c:		shortened_cwd = strstr(cwd, home);
src/main.c:		if (shortened_cwd != NULL)
src/main.c:			ft_strcat(prompt, "\033[1;37m");
src/main.c:			ft_strcat(prompt, shortened_cwd + strlen(home));
src/main.c:			ft_strcat(prompt, "\033[0m");
src/main.c:			ft_strcat(prompt, cwd);
src/main.c:	ft_strcat(prompt, "\033[1;36m $\033[0m ");
src/main.c: *                           
src/main.c: * possibility to add the path before prompt with this function
src/main.c: * (write a function "build_prompt")
src/main.c: * prompt = getcwd(NULL, 0);
src/main.c: *========================================================================**/
src/main.c:int	prompt_loop(t_Data *data, char *envp[])
src/main.c:	cmd[1] = NULL;
src/main.c:	while (1)
src/main.c:		cmd[0] = readline(prompt);
src/main.c:		if (cmd[0] && *cmd[0])
src/main.c:		if (cmd[0] == NULL)
src/main.c:			return (ft_printf("exit\n"), 0);
src/main.c:		exec_pipex(data, cmd[0], data->envp_tab);
src/main.c:	return (1);
src/main.c:int	is_only_space(char *str)
src/main.c:	i = 0;
src/main.c:	while (str[i])
src/main.c:		if (!ft_isspace(str[i]))
src/main.c:			return (0);
src/main.c:	return (1);
src/main.c: *                           command_is_builtin
src/main.c: * exit builtin implemented without extern function
src/main.c: * 0 is returned, and the data struct is freed in calling function
src/main.c: *========================================================================**/
src/main.c:int	command_is_builtin(char	*cmd_tab[], t_Data *data, char *envp[])
src/main.c:	if (!cmd_tab)
src/main.c:		return (1);
src/main.c:	if (!cmd_tab[0])
src/main.c:		return (free_command_tab(cmd_tab), 1);
src/main.c:	if (is_only_space(cmd_tab[0]))
src/main.c:		return (1);
src/main.c:	if (!ft_strncmp(&(cmd_tab[0][ft_strlen(cmd_tab[0]) - 4]), "echo", 5))
src/main.c:		return (exec_echo(data, cmd_tab), 1);
src/main.c:	if (!ft_strncmp(&(cmd_tab[0][ft_strlen(cmd_tab[0]) - 5]), "unset", 6))
src/main.c:		return (exec_unset(data, cmd_tab), 1);
src/main.c:	if (!ft_strncmp(&(cmd_tab[0][ft_strlen(cmd_tab[0]) - 6]), "export", 7))
src/main.c:		return (exec_export(cmd_tab, data), 1);
src/main.c:	if (!ft_strncmp(&(cmd_tab[0][ft_strlen(cmd_tab[0]) - 3]), "env", 4))
src/main.c:		return (exec_env(data, cmd_tab), 1);
src/main.c:	if (!ft_strncmp(&(cmd_tab[0][ft_strlen(cmd_tab[0]) - 3]), "pwd", 4))
src/main.c:		return (exec_pwd(data), 1);
src/main.c:	if (!ft_strncmp(&(cmd_tab[0][ft_strlen(cmd_tab[0]) - 2]), "cd", 3))
src/main.c:		return (exec_cd(data, cmd_tab), 1);
src/main.c:	if (!ft_strncmp(&(cmd_tab[0][ft_strlen(cmd_tab[0]) - 4]), "exit", 5))
src/main.c:		(exec_exit(data, cmd_tab));
src/main.c:	return (0);
src/main.c:	i = 0;
src/main.c:	while (envp_tab[i])
src/main.c:		if (!ft_strncmp(envp_tab[i], "SHLVL=", 6))
src/main.c:			shlvl = ft_atoi(&(envp_tab[i][6]));
src/main.c:			new_shlvl = ft_itoa(shlvl);
src/main.c:			ft_strlcpy(&envp_tab[i][6], new_shlvl, ft_strlen (new_shlvl) + 1);
src/main.c: *                           duplicate_envp
src/main.c: *========================================================================**/
src/main.c:char	**duplicate_envp(t_Data *data, char *envp[])
src/main.c:	i = 0;
src/main.c:	while (envp[i])
src/main.c:	envp_tab = (char **)ft_calloc(i + 1, sizeof(char *));
src/main.c:	if (envp_tab == NULL)
src/main.c:		return (NULL);
src/main.c:	i = 0;
src/main.c:	while (envp[i])
src/main.c:		envp_tab[i] = (char *)ft_calloc((ft_strlen(envp[i]) + 1), sizeof(char));
src/main.c:		if (envp_tab[i] == NULL)
src/main.c:			return (NULL);
src/main.c:		ft_strlcpy(envp_tab[i], envp[i], ft_strlen(envp[i]) + 1);
src/main.c:	envp_tab[i] = NULL;
src/main.c:	return (envp_tab);

Commande: echo 0
  0

Commande: /usr/bin/cat testfile
/usr/bin/cat: ' ': No such file or directory
test
motif olala
motif nononon
pôuet

Commande: echo 0
  0

Commande: /bin/grep -i motif /testfile
/bin/grep:  : No such file or directory
/bin/grep: motif: No such file or directory
/bin/grep:  : No such file or directory
/bin/grep: /testfile: No such file or directory

Commande: echo 0
  0

Commande: /bin/chmod 755 /testfile
/bin/chmod: invalid mode: ‘ ’
Try '/bin/chmod --help' for more information.

Commande: echo 0
  0

Commande: /bin/cp /testfile /includes/mon_fichier.txt
/bin/cp: target '/includes/mon_fichier.txt' is not a directory

Commande: echo 0
  0

Commande: /bin/mv /testfile /includes/mon_fichier.txt
/bin/mv: target '/includes/mon_fichier.txt' is not a directory

Commande: echo 0
  0

Commande: echo bonjour
  bonjour

Commande: echo 0
  0

Commande: echo     	
     

Commande: echo 0
  0

Commande: echo


Commande: echo 0
  0

Commande: echo -n au revoir
  -n   au   revoir

Commande: echo 0
  0

Commande: ls -a | rev
/usr/bin/ls: cannot access ' ': No such file or directory
/usr/bin/ls: cannot access ' ': No such file or directory

Commande: echo 0
  0

Commande: exit 42
exit

Commande: echo 0
  0

Commande: exit 42hgzef
exit

Commande: echo 0
  0

Commande: exit 42 jhgzegf
exit

Commande: echo 0
  0

Commande: exit jhzef
exit

Commande: echo 0
  0

Commande: ls -a
/usr/bin/ls: cannot access ' ': No such file or directory

Commande: echo 0
  0

Commande: <noexist cat
No such file or directory: noexist

Commande: echo 0
  0

Commande: bin/ls fichiernulachier
bin/ls: command not found

Commande: echo 0
  0

Commande: echo 0 + 0
  0   +   0

Commande: echo 0
  0

Commande: ls includes
/usr/bin/ls: cannot access ' ': No such file or directory
includes:
ls
minishell.h
parsing
pipex_setup.h

Commande: echo 0
  0

Commande: echo "cat lol.c | cat > lol.c"
  cat lol.c | cat > lol.c

Commande: echo 0
  0

Commande: ls inclu"des"
/usr/bin/ls: cannot access ' ': No such file or directory
includes:
ls
minishell.h
parsing
pipex_setup.h

Commande: echo 0
  0

Commande: l's' '-'l
/usr/bin/ls: cannot access ' ': No such file or directory

Commande: echo 0
  0

Commande: ls 
/usr/bin/ls: cannot access ' ': No such file or directory

Commande: echo 'seblin'
  seblin

Commande: echo 0
  0

Commande: cat includes/minishell.h
/usr/bin/cat: ' ': No such file or directory
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dan <dan@student.42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/01/12 08:59:03 by dan               #+#    #+#             */
/*   Updated: 2024/02/13 17:05:25 by dan              ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include <sys/wait.h>
# include <sys/types.h>
# include <signal.h>
# include <stdio.h>
# include <stdbool.h>
# include <stdio.h>
# include <unistd.h>
# include <stdlib.h>
# include "../lib/ft_printf/ft_printf.h"
# include "../lib/libft/libft.h"
// # include "../lib/get_next_line/get_next_line.h"
# include <readline/readline.h>
# include <readline/history.h>

typedef struct t_Data
{
	char	**envp_tab;
	int		exit_status;
}	t_Data;

void	handle_signals(void);
int		prompt_loop(t_Data *data, char *envp[]);
void	display_error(char *str);
void	free_data(t_Data *data);
void	close_minishell(t_Data *data);
void	exec_env(t_Data *data, char **command_tab);
int		command_is_builtin(char	*cmd[], t_Data *data, char *envp[]);
void	exec_pwd(t_Data *data);
int		exec_cd(t_Data *data, char **command_tab);
void	exec_echo(t_Data *data, char **command_tab);
void	exec_unset(t_Data *data, char **command_tab);
void	free_command_tab(char **command_tab);
char	**duplicate_envp(t_Data *data, char *envp[]);
int		exec_export(char **command_tab, t_Data *data);

#endif

Commande: echo 0
  0

Commande: echo 0
  0

Commande: echo papa >> file1


Commande: echo 0
  0

Commande: echo maman >> file1


Commande: echo 0
  0

Commande: cat file1
papa
papa
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
maman
papa
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
papa
maman
maman
papa
maman

Commande: echo 0
  0

Commande: cat file1 | grep papa | more


Commande: echo 0
  0

Commande: << end cat|>fileout
heredoc> warning: here-document at line 1 delimited by end-of-file (wanted ' ')

Commande: echo 0
  0

Commande: ls fichiernul | grep bla | more
/usr/bin/ls: cannot access 'fichiernul': No such file or directory

Commande: echo 0
  0

Commande: export VAR=tamaman


Commande: echo 0
  0

Commande: echo 
 

Commande: echo 0
  0

Commande: echo 
 

Commande: unset VAR


Commande: echo 0
  0

Commande: echo 
 

Commande: echo 0
  0

Commande: unset PATH


Commande: echo 0
  0

Commande: ls
 
Makefile
README.md
allowed_functions.md
bash_output.txt
compare_bash_and_minishell.sh
correct_output.txt
diff_output.txt
en.subject.pdf
eval_minishell.pdf
fie
file
file1
fileout
fille
fou
includes
lib
minishell
minishell_output.txt
minishell_tester
moutou
not_existing
notexisting
outfile
outfille
outfille2
output.txt
src
test_commands.txt
test_lucas
testfile
tests.sh
to_test
token
valgrind.supp
wc

Commande: echo 0
  0

Commande: cd ..
minishell: cd: too many arguments

Commande: pwd
/home/seblin/42/42_minishell

Commande: echo 0
  0

Commande: cd


Commande: echo 0
  0

Commande: pwd
/home/seblin/42/42_minishell

Commande: echo 0
  0

Commande: pwd kzbgkbzekgb
/home/seblin/42/42_minishell

Commande: echo 0
  0

Commande: pwd kzbg  kbzekgb
/home/seblin/42/42_minishell

Commande: echo 0
  0

Commande: pwd 42 bzekgb
/home/seblin/42/42_minishell

Commande: echo 0
  0

Commande: cat includes/minishell.h
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dan <dan@student.42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/01/12 08:59:03 by dan               #+#    #+#             */
/*   Updated: 2024/02/13 17:05:25 by dan              ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include <sys/wait.h>
# include <sys/types.h>
# include <signal.h>
# include <stdio.h>
# include <stdbool.h>
# include <stdio.h>
# include <unistd.h>
# include <stdlib.h>
# include "../lib/ft_printf/ft_printf.h"
# include "../lib/libft/libft.h"
// # include "../lib/get_next_line/get_next_line.h"
# include <readline/readline.h>
# include <readline/history.h>

typedef struct t_Data
{
	char	**envp_tab;
	int		exit_status;
}	t_Data;

void	handle_signals(void);
int		prompt_loop(t_Data *data, char *envp[]);
void	display_error(char *str);
void	free_data(t_Data *data);
void	close_minishell(t_Data *data);
void	exec_env(t_Data *data, char **command_tab);
int		command_is_builtin(char	*cmd[], t_Data *data, char *envp[]);
void	exec_pwd(t_Data *data);
int		exec_cd(t_Data *data, char **command_tab);
void	exec_echo(t_Data *data, char **command_tab);
void	exec_unset(t_Data *data, char **command_tab);
void	free_command_tab(char **command_tab);
char	**duplicate_envp(t_Data *data, char *envp[]);
int		exec_export(char **command_tab, t_Data *data);

#endif

Commande: echo 0
  0

Commande: cat ../../42/minishell_common/includes/minishell.h
/usr/bin/cat: ../../42/minishell_common/includes/minishell.h: No such file or directory

Commande: echo 0
  0

Commande: <testfile cat | rev > outfile


Commande: echo 0
  0

Commande: cat <testfile


Commande: echo 0
  0

Commande: <outfile cat


Commande: echo 0
  0

Commande: <testfile cat | echo niania | rev > outfile


Commande: echo 0
  0

Commande: <outfile cat


Commande: echo 0
  0

Commande: <testfile cat | echeo niania | rev > outfile


Commande: echo 0
  0

Commande: <outfile cat


Commande: echo 0
  0

Commande: echo aaa && echo bbb || echo ccc
  aaa  

Commande: echo 0
  0

Commande: echo aaa || echo bbb || echo ccc
  aaa  

Commande: echo 0
  0

Commande: echo 0
  0

Commande: false && echo bbb || echo ccc


Commande: echo 0
  0

Commande: false || echo bbb || echo ccc


Commande: echo 0
  0

Commande: false && echo bbb && echo ccc


Commande: echo 0
  0

Commande: echo aaa && false && echo ccc
  aaa  

Commande: echo 0
  0

Commande: <<end <<end
heredoc> warning: here-document at line 1 delimited by end-of-file (wanted 'end')
heredoc> warning: here-document at line 1 delimited by end-of-file (wanted 'end')

Commande: <<end cat
heredoc> warning: here-document at line 1 delimited by end-of-file (wanted 'end')

Commande: <<end
heredoc> warning: here-document at line 1 delimited by end-of-file (wanted 'end')

Commande: echo 0
  0

Commande: echo /bin/bash
  /bin/bash

Commande: echo 0
  0

Commande: echo seblin/bin/bash$
  seblin/bin/bash$

Commande: echo 0
  0

Commande: echo seblin/bin/bash
  seblin/bin/bash

Commande: echo 0
  0

Commande: echo seblin   /bin/bash $
  seblin     /bin/bash   $

Commande: echo 0
  0

Commande: echo 'seblin/bin/bash$'
  seblin/bin/bash$

Commande: echo 0
  0

Commande: echo seblin /bin/bash $ 
  seblin   /bin/bash   $  

Commande: echo 0
  0

Commande: echo seblin/bin/bash
  seblin/bin/bash

Commande: echo 0
  0

Commande: echo "seblin$  SHELL $ "
  seblin$  SHELL $ 

Commande: echo 0
  0

Commande: echo "trrtseblin$   SHELL $ "
  trrtseblin$   SHELL $ 

Commande: echo 0
  0

Commande: echo "trrtseblin   SHELL $ "
  trrtseblin   SHELL $ 

Commande: echo 0
  0

Commande: echo "trrtseblin SHELL $ "
  trrtseblin SHELL $ 

Commande: echo 0
  0

Commande: echo trrtseblin$   SHELL $ 
  trrtseblin$     SHELL   $  

Commande: echo 0
  0

Commande: echo "trrtseblin'Mach' $'LOGNAME'  SHELL $ "
  trrtseblin'Mach' $'LOGNAME'  SHELL $ 

Commande: echo 0
  0

Commande: echo "trrt'Mach' seblin'Mach' $'LOGNA'M''E'  SHELL $ "
  trrt'Mach' seblin'Mach' $'LOGNA'M''E'  SHELL $ 

Commande: echo 0
  0

Commande: echo "trrt'Mach'p louseblin'Mach' $'LOGNA'M''E'42  SHELL $ "
  trrt'Mach'p louseblin'Mach' $'LOGNA'M''E'42  SHELL $ 

Commande: echo 0
  0

Commande: echo "seblin"
  seblin

Commande: echo 0
  0

Commande: echo seblin
  seblin

Commande: echo 0
  0

